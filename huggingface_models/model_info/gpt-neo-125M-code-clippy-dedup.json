{"pretrained_model_name": "flax-community/gpt-neo-125M-code-clippy-dedup", "description": "# GPT-Neo-125M-Code-Clippy-Dedup\n> **Please refer to our new [GitHub Wiki](https://github.com/ncoop57/gpt-code-clippy/wiki) which documents our efforts in detail in creating the open source version of GitHub  Copilot**\n\n## Model Description\n\nPT-Neo-125M-Code-Clippy-Dedup is a [GPT-Neo-125M model](https://huggingface.co/EleutherAI/gpt-neo-125M) finetuned using causal language modeling on our deduplicated version of the Code Clippy Data dataset, which was scraped from public Github repositories (more information in the provided link). This model is specialized to autocomplete methods in multiple programming languages. \n\n\n\n## Training data\n\n[Code Clippy Data dataset](https://huggingface.co/datasets/code_search_net).\n\n## Training procedure\n\nIn this model's training we tried to stabilize the training by limiting the types of files we were using to train to only those that contained file extensions for popular programming languages as our dataset contains other types of files as well such as `.txt` or project configuration files. We used the following extensions to filter by:\n\nThe training script used to train this model can be found [here](https://github.com/ncoop57/gpt-code-clippy/blob/camera-ready/training/run_clm_streaming_filter_flax.py).\n\n```bash\n./run_clm_streaming_filter_flax.py \\\n    --output_dir $HOME/gpt-neo-125M-code-clippy-dedup \\\n    --model_name_or_path=\"EleutherAI/gpt-neo-125M\" \\\n    --dataset_name $HOME/gpt-code-clippy/data_processing/code_clippy_filter.py \\\n    --data_dir $HOME/code_clippy_data/code_clippy_dedup_data \\\n    --text_column_name=\"text\" \\\n    --do_train --do_eval \\\n    --block_size=\"2048\" \\\n    --per_device_train_batch_size=\"8\" \\\n    --per_device_eval_batch_size=\"16\" \\\n    --preprocessing_num_workers=\"8\" \\\n    --learning_rate=\"1e-4\" \\\n    --max_steps 100000 \\\n    --warmup_steps 2000 \\\n    --decay_steps 30000 \\\n    --adam_beta1=\"0.9\" \\\n    --adam_beta2=\"0.95\" \\\n    --weight_decay=\"0.1\" \\\n    --overwrite_output_dir \\\n    --logging_steps=\"25\" \\\n    --eval_steps=\"500\" \\\n    --push_to_hub=\"False\" \\\n    --report_to=\"all\" \\\n    --dtype=\"bfloat16\" \\\n    --skip_memory_metrics=\"True\" \\\n    --save_steps=\"500\" \\\n    --save_total_limit 10 \\\n    --gradient_accumulation_steps 16 \\\n    --report_to=\"wandb\" \\\n    --run_name=\"gpt-neo-125M-code-clippy-dedup-filtered-no-resize-2048bs\" \\\n    --max_eval_samples 2000 \\\n    --save_optimizer true\n```\n\n## Intended Use and Limitations\n\nThe model is finetuned text file from github repositories (mostly programming languages but also markdown and other project related files).\n\n### How to use\n\nYou can use this model directly with a pipeline for text generation. This example generates a different sequence each time it's run:\n\n```py\n\nfrom transformers import AutoModelForCausalLM, AutoTokenizer, FlaxAutoModelForCausalLM\n\nmodel = AutoModelForCausalLM.from_pretrained(\"flax-community/gpt-neo-125M-code-clippy-dedup\")\n\ntokenizer = AutoTokenizer.from_pretrained(\"flax-community/gpt-neo-125M-code-clippy-dedup\")\n\nprompt = \"\"\"def greet(name):\n  '''A function to greet user. Given a user name it should say hello'''\n\"\"\" \n\ninput_ids = tokenizer(prompt, return_tensors='pt').input_ids.to(device)\n\nstart = input_ids.size(1)\n\nout = model.generate(input_ids, do_sample=True, max_length=50, num_beams=2, \n\n                     early_stopping=True, eos_token_id=tokenizer.eos_token_id, )\n\nprint(tokenizer.decode(out[0][start:]))\n\n```\n\n### Limitations and Biases\n\nThe model is intended to be used for research purposes and comes with no guarantees of quality of generated code.\n\nThe paper [\"Evaluating Large Language Models Trained on Code\"](https://arxiv.org/abs/2107.03374) from OpenAI has a good discussion on what the impact of a large language model trained on code could be. Therefore, some parts of their discuss are highlighted here as it pertains to this dataset and models that may be trained from it. **As well as some differences in views from the paper, particularly around legal implications**.\n\n1. **Over-reliance:** This model may generate plausible solutions that may appear correct, but are not necessarily the correct solution. Not properly evaluating the generated code may cause have negative consequences such as the introduction of bugs, or the introduction of security vulnerabilities. Therefore, it is important that users are aware of the limitations and potential negative consequences of using this language model.\n2. **Economic and labor market impacts:** Large language models trained on large code datasets such as this one that are capable of generating high-quality code have the potential to automate part of the software development process. This may negatively impact software developers. However, as discussed in the paper, as shown in the Summary Report of software developers from [O*NET OnLine](https://www.onetonline.org/link/summary/15-1252.00), developers don't just write software.\n3. **Security implications:** No filtering or checking of vulnerabilities or buggy code was performed on the datase this model is trained on. This means that the dataset may contain code that may be malicious or contain vulnerabilities. Therefore, this model may generate vulnerable, buggy, or malicious code. In safety critical software, this could lead to software that may work improperly and could result in serious consequences depending on the software. Additionally, this model may be able to be used to generate malicious code on purpose in order to perform ransomware or other such attacks.\n4. **Legal implications:** No filtering was performed on licensed code. This means that the dataset may contain restrictive licensed code. As discussed in the paper, public Github repositories may fall under \"fair use.\" However, there has been little to no previous cases of such usages of licensed publicly available code. Therefore, any code generated with this model may be required to obey license terms that align with the software it was trained on such as GPL-3.0. It is unclear the legal ramifications of using a language model trained on this dataset.\n5. **Biases:** The programming languages most represented in the dataset this model was trained on are Javascript and Python. Therefore, other, still popular languages such as C and C++, are less represented and therefore the models performance for these languages will be less comparatively. Additionally, this dataset only contains public repositories and so the model may not generate code that is representative of code written by private developers. No filtering was performed for potential racist, offensive, or otherwise inappropriate content. Therefore, this model may reflect such biases in its generation.\n\nGPT-Neo-125M-Code-Clippy-Dedup is finetuned from GPT-Neo and might have inherited biases and limitations from it. See [GPT-Neo model card](https://huggingface.co/EleutherAI/gpt-neo-125M#limitations-and-biases) for details.\n\n## Eval results\n\nComing soon...", "size_bytes": "526020317", "downloads": 46}