{"pretrained_model_name": "ml6team/keyphrase-generation-keybart-inspec", "description": "---\nlanguage: en\nlicense: mit\ntags:\n- keyphrase-generation\ndatasets:\n- midas/inspec\nwidget:\n- text: \"Keyphrase extraction is a technique in text analysis where you extract the important keyphrases from a document. \nThanks to these keyphrases humans can understand the content of a text very quickly and easily without reading \nit completely. Keyphrase extraction was first done primarily by human annotators, who read the text in detail \nand then wrote down the most important keyphrases. The disadvantage is that if you work with a lot of documents, \nthis process can take a lot of time. \n\nHere is where Artificial Intelligence comes in. Currently, classical machine learning methods, that use statistical \nand linguistic features, are widely used for the extraction process. Now with deep learning, it is possible to capture \nthe semantic meaning of a text even better than these classical methods. Classical methods look at the frequency, \noccurrence and order of words in the text, whereas these neural approaches can capture long-term semantic dependencies \nand context of words in a text.\"\n  example_title: \"Example 1\"\n- text: \"In this work, we explore how to learn task specific language models aimed towards learning rich representation of keyphrases from text documents. We experiment with different masking strategies for pre-training transformer language models (LMs) in discriminative as well as generative settings. In the discriminative setting, we introduce a new pre-training objective - Keyphrase Boundary Infilling with Replacement (KBIR), showing large gains in performance (up to 9.26 points in F1) over SOTA, when LM pre-trained using KBIR is fine-tuned for the task of keyphrase extraction. In the generative setting, we introduce a new pre-training setup for BART - KeyBART, that reproduces the keyphrases related to the input text in the CatSeq format, instead of the denoised original input. This also led to gains in performance (up to 4.33 points inF1@M) over SOTA for keyphrase generation. Additionally, we also fine-tune the pre-trained language models on named entity recognition(NER), question answering (QA), relation extraction (RE), abstractive summarization and achieve comparable performance with that of the SOTA, showing that learning rich representation of keyphrases is indeed beneficial for many other fundamental NLP tasks.\"\n  example_title: \"Example 2\"\nmodel-index:\n- name: DeDeckerThomas/keyphrase-generation-keybart-inspec\n  results:\n  - task: \n      type: keyphrase-generation\n      name: Keyphrase Generation\n    dataset:\n      type: midas/inspec\n      name: inspec\n    metrics:\n      - type: F1@M (Present)\n        value: 0.361\n        name: F1@M (Present)\n      - type: F1@O (Present)\n        value: 0.329\n        name: F1@O (Present)\n      - type: F1@M (Absent)\n        value: 0.083\n        name: F1@M (Absent)\n      - type: F1@O (Absent)\n        value: 0.080\n        name: F1@O (Absent)\n---\n\n# \ud83d\udd11 Keyphrase Generation Model: KeyBART-inspec\nKeyphrase extraction is a technique in text analysis where you extract the important keyphrases from a document. Thanks to these keyphrases humans can understand the content of a text very quickly and easily without reading it completely. Keyphrase extraction was first done primarily by human annotators, who read the text in detail and then wrote down the most important keyphrases. The disadvantage is that if you work with a lot of documents, this process can take a lot of time \u23f3. \n\nHere is where Artificial Intelligence \ud83e\udd16 comes in. Currently, classical machine learning methods, that use statistical and linguistic features, are widely used for the extraction process. Now with deep learning, it is possible to capture the semantic meaning of a text even better than these classical methods. Classical methods look at the frequency, occurrence and order of words in the text, whereas these neural approaches can capture long-term semantic dependencies and context of words in a text.\n\n## \ud83d\udcd3 Model Description\nThis model uses [KeyBART](https://huggingface.co/bloomberg/KeyBART) as its base model and fine-tunes it on the [Inspec dataset](https://huggingface.co/datasets/midas/inspec). KeyBART focuses on learning a better representation of keyphrases in a generative setting. It produces the keyphrases associated with the input document from a corrupted input. The input is changed by token masking, keyphrase masking and keyphrase replacement. This model can already be used without any fine-tuning, but can be fine-tuned if needed.\nYou can find more information about the architecture in this [paper](https://arxiv.org/abs/2112.08547).\n\nKulkarni, Mayank, Debanjan Mahata, Ravneet Arora, and Rajarshi Bhowmik. \"Learning Rich Representation of Keyphrases from Text.\" arXiv preprint arXiv:2112.08547 (2021).\n\n## \u270b Intended Uses & Limitations\n### \ud83d\uded1 Limitations\n* This keyphrase generation model is very domain-specific and will perform very well on abstracts of scientific papers. It's not recommended to use this model for other domains, but you are free to test it out.\n* Only works for English documents.\n\n### \u2753 How To Use\n```python\n# Model parameters\nfrom transformers import (\n    Text2TextGenerationPipeline,\n    AutoModelForSeq2SeqLM,\n    AutoTokenizer,\n)\n\n\nclass KeyphraseGenerationPipeline(Text2TextGenerationPipeline):\n    def __init__(self, model, keyphrase_sep_token=\";\", *args, **kwargs):\n        super().__init__(\n            model=AutoModelForSeq2SeqLM.from_pretrained(model),\n            tokenizer=AutoTokenizer.from_pretrained(model),\n            *args,\n            **kwargs\n        )\n        self.keyphrase_sep_token = keyphrase_sep_token\n\n    def postprocess(self, model_outputs):\n        results = super().postprocess(\n            model_outputs=model_outputs\n        )\n        return [[keyphrase.strip() for keyphrase in result.get(\"generated_text\").split(self.keyphrase_sep_token) if keyphrase != \"\"] for result in results]\n\n```\n\n```python\n# Load pipeline\nmodel_name = \"ml6team/keyphrase-generation-keybart-inspec\"\ngenerator = KeyphraseGenerationPipeline(model=model_name)\n```\n\n```python\n# Inference\ntext = \"\"\"\nKeyphrase extraction is a technique in text analysis where you extract the\nimportant keyphrases from a document. Thanks to these keyphrases humans can\nunderstand the content of a text very quickly and easily without reading it\ncompletely. Keyphrase extraction was first done primarily by human annotators,\nwho read the text in detail and then wrote down the most important keyphrases.\nThe disadvantage is that if you work with a lot of documents, this process\ncan take a lot of time. \n\nHere is where Artificial Intelligence comes in. Currently, classical machine\nlearning methods, that use statistical and linguistic features, are widely used\nfor the extraction process. Now with deep learning, it is possible to capture\nthe semantic meaning of a text even better than these classical methods.\nClassical methods look at the frequency, occurrence and order of words\nin the text, whereas these neural approaches can capture long-term\nsemantic dependencies and context of words in a text.\n\"\"\".replace(\"\\n\", \" \")\n\nkeyphrases = generator(text)\n\nprint(keyphrases)\n\n```\n\n```\n# Output\n[['keyphrase extraction', 'text analysis', 'keyphrases', 'human annotators', 'artificial']]\n```\n\n## \ud83d\udcda Training Dataset\n[Inspec](https://huggingface.co/datasets/midas/inspec) is a keyphrase extraction/generation dataset consisting of 2000 English scientific papers from the scientific domains of Computers and Control and Information Technology published between 1998 to 2002. The keyphrases are annotated by professional indexers or editors.\n\nYou can find more information in the [paper](https://dl.acm.org/doi/10.3115/1119355.1119383).\n\n## \ud83d\udc77\u200d\u2642\ufe0f Training Procedure\n### Training Parameters\n\n| Parameter | Value |\n| --------- | ------|\n| Learning Rate | 5e-5 |\n| Epochs | 15 |\n| Early Stopping Patience | 1 |\n\n### Preprocessing\nThe documents in the dataset are already preprocessed into list of words with the corresponding keyphrases. The only thing that must be done is tokenization and joining all keyphrases into one string with a certain seperator of choice( ```;``` ). \n```python\nfrom datasets import load_dataset\nfrom transformers import AutoTokenizer\n\n# Tokenizer\ntokenizer = AutoTokenizer.from_pretrained(\"bloomberg/KeyBART\", add_prefix_space=True)\n\n# Dataset parameters\ndataset_full_name = \"midas/inspec\"\ndataset_subset = \"raw\"\ndataset_document_column = \"document\"\n\nkeyphrase_sep_token = \";\"\n\ndef preprocess_keyphrases(text_ids, kp_list):\n    kp_order_list = []\n    kp_set = set(kp_list)\n    text = tokenizer.decode(\n        text_ids, skip_special_tokens=True, clean_up_tokenization_spaces=True\n    )\n    text = text.lower()\n    for kp in kp_set:\n        kp = kp.strip()\n        kp_index = text.find(kp.lower())\n        kp_order_list.append((kp_index, kp))\n\n    kp_order_list.sort()\n    present_kp, absent_kp = [], []\n\n    for kp_index, kp in kp_order_list:\n        if kp_index < 0:\n            absent_kp.append(kp)\n        else:\n            present_kp.append(kp)\n    return present_kp, absent_kp\n\n\ndef preprocess_fuction(samples):\n    processed_samples = {\"input_ids\": [], \"attention_mask\": [], \"labels\": []}\n    for i, sample in enumerate(samples[dataset_document_column]):\n        input_text = \" \".join(sample)\n        inputs = tokenizer(\n            input_text,\n            padding=\"max_length\",\n            truncation=True,\n        )\n        present_kp, absent_kp = preprocess_keyphrases(\n            text_ids=inputs[\"input_ids\"],\n            kp_list=samples[\"extractive_keyphrases\"][i]\n            + samples[\"abstractive_keyphrases\"][i],\n        )\n        keyphrases = present_kp\n        keyphrases += absent_kp\n\n        target_text = f\" {keyphrase_sep_token} \".join(keyphrases)\n\n        with tokenizer.as_target_tokenizer():\n            targets = tokenizer(\n                target_text, max_length=40, padding=\"max_length\", truncation=True\n            )\n            targets[\"input_ids\"] = [\n                (t if t != tokenizer.pad_token_id else -100)\n                for t in targets[\"input_ids\"]\n            ]\n        for key in inputs.keys():\n            processed_samples[key].append(inputs[key])\n        processed_samples[\"labels\"].append(targets[\"input_ids\"])\n    return processed_samples\n\n# Load dataset\ndataset = load_dataset(dataset_full_name, dataset_subset)\n# Preprocess dataset\ntokenized_dataset = dataset.map(preprocess_fuction, batched=True)\n    \n```\n\n### Postprocessing\nFor the post-processing, you will need to split the string based on the keyphrase separator.\n```python\ndef extract_keyphrases(examples):\n    return [example.split(keyphrase_sep_token) for example in examples]\n```\n## \ud83d\udcdd Evaluation results\nTraditional evaluation methods are the precision, recall and F1-score @k,m where k is the number that stands for the first k predicted keyphrases and m for the average amount of predicted keyphrases. In keyphrase generation you also look at F1@O where O stands for the number of ground truth keyphrases.\n\nThe model achieves the following results on the Inspec test set:\n\n\n### Extractive Keyphrases\n\n| Dataset           | P@5  | R@5  | F1@5 | P@10 | R@10 | F1@10 | P@M  | R@M  | F1@M | P@O  | R@O  | F1@O |\n|:-----------------:|:----:|:----:|:----:|:----:|:----:|:-----:|:----:|:----:|:----:|:----:|:----:|:----:|\n| Inspec Test Set   | 0.40 | 0.37 | 0.35 | 0.20 | 0.37 | 0.24  | 0.42 | 0.37 | 0.36 | 0.33 | 0.33 | 0.33 |\n\n### Abstractive Keyphrases\n\n| Dataset           | P@5  | R@5  | F1@5 | P@10 | R@10 | F1@10 | P@M  | R@M  | F1@M | P@O  | R@O  | F1@O |\n|:-----------------:|:----:|:----:|:----:|:----:|:----:|:-----:|:----:|:----:|:----:|:----:|:----:|:----:|\n| Inspec Test Set   | 0.07 | 0.12 | 0.08 | 0.03 | 0.12 | 0.05  | 0.08 | 0.12 | 0.08 | 0.08 | 0.12 | 0.08 |\n\n## \ud83d\udea8 Issues\nPlease feel free to start discussions in the Community Tab.", "size_bytes": "1625537793", "downloads": 200}