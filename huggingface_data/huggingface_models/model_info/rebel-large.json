{"pretrained_model_name": "Babelscape/rebel-large", "description": "---\nlanguage:\n- en\nwidget:\n- text: \"Punta Cana is a resort town in the municipality of Higuey, in La Altagracia Province, the eastern most province of the Dominican Republic\"\ntags:\n- seq2seq\n- relation-extraction\ndatasets:\n- Babelscape/rebel-dataset\nmodel-index:\n- name: REBEL\n  results:\n  - task:\n      name: Relation Extraction\n      type: Relation-Extraction\n    dataset:\n      name: \"CoNLL04\"\n      type: CoNLL04\n    metrics:\n       - name: RE+ Macro F1 \n         type: re+ macro f1\n         value: 76.65\n  - task:\n      name: Relation Extraction\n      type: Relation-Extraction\n    dataset:\n      name: \"NYT\"\n      type: NYT\n    metrics:\n       - name: F1  \n         type: f1\n         value: 93.4\nlicense: cc-by-nc-sa-4.0\n---\n[![PWC](https://img.shields.io/endpoint.svg?url=https://paperswithcode.com/badge/rebel-relation-extraction-by-end-to-end/relation-extraction-on-nyt)](https://paperswithcode.com/sota/relation-extraction-on-nyt?p=rebel-relation-extraction-by-end-to-end)\n[![PWC](https://img.shields.io/endpoint.svg?url=https://paperswithcode.com/badge/rebel-relation-extraction-by-end-to-end/relation-extraction-on-conll04)](https://paperswithcode.com/sota/relation-extraction-on-conll04?p=rebel-relation-extraction-by-end-to-end)\n[![PWC](https://img.shields.io/endpoint.svg?url=https://paperswithcode.com/badge/rebel-relation-extraction-by-end-to-end/joint-entity-and-relation-extraction-on-3)](https://paperswithcode.com/sota/joint-entity-and-relation-extraction-on-3?p=rebel-relation-extraction-by-end-to-end)\n[![PWC](https://img.shields.io/endpoint.svg?url=https://paperswithcode.com/badge/rebel-relation-extraction-by-end-to-end/relation-extraction-on-ade-corpus)](https://paperswithcode.com/sota/relation-extraction-on-ade-corpus?p=rebel-relation-extraction-by-end-to-end)\n[![PWC](https://img.shields.io/endpoint.svg?url=https://paperswithcode.com/badge/rebel-relation-extraction-by-end-to-end/relation-extraction-on-re-tacred)](https://paperswithcode.com/sota/relation-extraction-on-re-tacred?p=rebel-relation-extraction-by-end-to-end)\n\n## Multilingual update! Check [mREBEL](https://huggingface.co/Babelscape/mrebel-large), a multilingual version covering more relation types, languages and including entity types.\n\n# REBEL <img src=\"https://i.ibb.co/qsLzNqS/hf-rebel.png\" width=\"30\" alt=\"hf-rebel\" border=\"0\" style=\"display:inline; white-space:nowrap;\">: Relation Extraction By End-to-end Language generation\nThis is the model card for the Findings of EMNLP 2021 paper [REBEL: Relation Extraction By End-to-end Language generation](https://github.com/Babelscape/rebel/blob/main/docs/EMNLP_2021_REBEL__Camera_Ready_.pdf). We present a new linearization approach and a reframing of Relation Extraction as a seq2seq task. The paper can be found [here](https://github.com/Babelscape/rebel/blob/main/docs/EMNLP_2021_REBEL__Camera_Ready_.pdf). If you use the code, please reference this work in your paper:\n\n    @inproceedings{huguet-cabot-navigli-2021-rebel-relation,\n        title = \"{REBEL}: Relation Extraction By End-to-end Language generation\",\n        author = \"Huguet Cabot, Pere-Llu{\\'\\i}s  and\n          Navigli, Roberto\",\n        booktitle = \"Findings of the Association for Computational Linguistics: EMNLP 2021\",\n        month = nov,\n        year = \"2021\",\n        address = \"Punta Cana, Dominican Republic\",\n        publisher = \"Association for Computational Linguistics\",\n        url = \"https://aclanthology.org/2021.findings-emnlp.204\",\n        pages = \"2370--2381\",\n        abstract = \"Extracting relation triplets from raw text is a crucial task in Information Extraction, enabling multiple applications such as populating or validating knowledge bases, factchecking, and other downstream tasks. However, it usually involves multiple-step pipelines that propagate errors or are limited to a small number of relation types. To overcome these issues, we propose the use of autoregressive seq2seq models. Such models have previously been shown to perform well not only in language generation, but also in NLU tasks such as Entity Linking, thanks to their framing as seq2seq tasks. In this paper, we show how Relation Extraction can be simplified by expressing triplets as a sequence of text and we present REBEL, a seq2seq model based on BART that performs end-to-end relation extraction for more than 200 different relation types. We show our model{'}s flexibility by fine-tuning it on an array of Relation Extraction and Relation Classification benchmarks, with it attaining state-of-the-art performance in most of them.\",\n    }\n\nThe original repository for the paper can be found [here](https://github.com/Babelscape/rebel)\n\nBe aware that the inference widget at the right does not output special tokens, which are necessary to distinguish the subject, object and relation types. For a demo of REBEL and its pre-training dataset check the [Spaces demo](https://huggingface.co/spaces/Babelscape/rebel-demo).\n\n## Pipeline usage\n\n```python\nfrom transformers import pipeline\n\ntriplet_extractor = pipeline('text2text-generation', model='Babelscape/rebel-large', tokenizer='Babelscape/rebel-large')\n# We need to use the tokenizer manually since we need special tokens.\nextracted_text = triplet_extractor.tokenizer.batch_decode([triplet_extractor(\"Punta Cana is a resort town in the municipality of Higuey, in La Altagracia Province, the eastern most province of the Dominican Republic\", return_tensors=True, return_text=False)[0][\"generated_token_ids\"]])\nprint(extracted_text[0])\n# Function to parse the generated text and extract the triplets\ndef extract_triplets(text):\n    triplets = []\n    relation, subject, relation, object_ = '', '', '', ''\n    text = text.strip()\n    current = 'x'\n    for token in text.replace(\"<s>\", \"\").replace(\"<pad>\", \"\").replace(\"</s>\", \"\").split():\n        if token == \"<triplet>\":\n            current = 't'\n            if relation != '':\n                triplets.append({'head': subject.strip(), 'type': relation.strip(),'tail': object_.strip()})\n                relation = ''\n            subject = ''\n        elif token == \"<subj>\":\n            current = 's'\n            if relation != '':\n                triplets.append({'head': subject.strip(), 'type': relation.strip(),'tail': object_.strip()})\n            object_ = ''\n        elif token == \"<obj>\":\n            current = 'o'\n            relation = ''\n        else:\n            if current == 't':\n                subject += ' ' + token\n            elif current == 's':\n                object_ += ' ' + token\n            elif current == 'o':\n                relation += ' ' + token\n    if subject != '' and relation != '' and object_ != '':\n        triplets.append({'head': subject.strip(), 'type': relation.strip(),'tail': object_.strip()})\n    return triplets\nextracted_triplets = extract_triplets(extracted_text[0])\nprint(extracted_triplets)\n```\n\n## Model and Tokenizer using transformers\n\n```python\nfrom transformers import AutoModelForSeq2SeqLM, AutoTokenizer\n\ndef extract_triplets(text):\n    triplets = []\n    relation, subject, relation, object_ = '', '', '', ''\n    text = text.strip()\n    current = 'x'\n    for token in text.replace(\"<s>\", \"\").replace(\"<pad>\", \"\").replace(\"</s>\", \"\").split():\n        if token == \"<triplet>\":\n            current = 't'\n            if relation != '':\n                triplets.append({'head': subject.strip(), 'type': relation.strip(),'tail': object_.strip()})\n                relation = ''\n            subject = ''\n        elif token == \"<subj>\":\n            current = 's'\n            if relation != '':\n                triplets.append({'head': subject.strip(), 'type': relation.strip(),'tail': object_.strip()})\n            object_ = ''\n        elif token == \"<obj>\":\n            current = 'o'\n            relation = ''\n        else:\n            if current == 't':\n                subject += ' ' + token\n            elif current == 's':\n                object_ += ' ' + token\n            elif current == 'o':\n                relation += ' ' + token\n    if subject != '' and relation != '' and object_ != '':\n        triplets.append({'head': subject.strip(), 'type': relation.strip(),'tail': object_.strip()})\n    return triplets\n\n# Load model and tokenizer\ntokenizer = AutoTokenizer.from_pretrained(\"Babelscape/rebel-large\")\nmodel = AutoModelForSeq2SeqLM.from_pretrained(\"Babelscape/rebel-large\")\ngen_kwargs = {\n    \"max_length\": 256,\n    \"length_penalty\": 0,\n    \"num_beams\": 3,\n    \"num_return_sequences\": 3,\n}\n\n# Text to extract triplets from\ntext = 'Punta Cana is a resort town in the municipality of Hig\u00fcey, in La Altagracia Province, the easternmost province of the Dominican Republic.'\n\n# Tokenizer text\nmodel_inputs = tokenizer(text, max_length=256, padding=True, truncation=True, return_tensors = 'pt')\n\n# Generate\ngenerated_tokens = model.generate(\n    model_inputs[\"input_ids\"].to(model.device),\n    attention_mask=model_inputs[\"attention_mask\"].to(model.device),\n    **gen_kwargs,\n)\n\n# Extract text\ndecoded_preds = tokenizer.batch_decode(generated_tokens, skip_special_tokens=False)\n\n# Extract triplets\nfor idx, sentence in enumerate(decoded_preds):\n    print(f'Prediction triplets sentence {idx}')\n    print(extract_triplets(sentence))\n```", "size_bytes": "1625590959", "downloads": 59655}