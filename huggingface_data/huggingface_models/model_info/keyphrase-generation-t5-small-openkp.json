{"pretrained_model_name": "ml6team/keyphrase-generation-t5-small-openkp", "description": "---\nlanguage: en\nlicense: mit\ntags:\n- keyphrase-generation\ndatasets:\n- midas/openkp\nwidget:\n- text: \"Keyphrase extraction is a technique in text analysis where you extract the important keyphrases from a document. \nThanks to these keyphrases humans can understand the content of a text very quickly and easily without reading \nit completely. Keyphrase extraction was first done primarily by human annotators, who read the text in detail \nand then wrote down the most important keyphrases. The disadvantage is that if you work with a lot of documents, \nthis process can take a lot of time. \n\nHere is where Artificial Intelligence comes in. Currently, classical machine learning methods, that use statistical \nand linguistic features, are widely used for the extraction process. Now with deep learning, it is possible to capture \nthe semantic meaning of a text even better than these classical methods. Classical methods look at the frequency, \noccurrence and order of words in the text, whereas these neural approaches can capture long-term semantic dependencies \nand context of words in a text.\"\n  example_title: \"Example 1\"\n- text: \"In this work, we explore how to learn task specific language models aimed towards learning rich representation of keyphrases from text documents. We experiment with different masking strategies for pre-training transformer language models (LMs) in discriminative as well as generative settings. In the discriminative setting, we introduce a new pre-training objective - Keyphrase Boundary Infilling with Replacement (KBIR), showing large gains in performance (up to 9.26 points in F1) over SOTA, when LM pre-trained using KBIR is fine-tuned for the task of keyphrase extraction. In the generative setting, we introduce a new pre-training setup for BART - KeyBART, that reproduces the keyphrases related to the input text in the CatSeq format, instead of the denoised original input. This also led to gains in performance (up to 4.33 points inF1@M) over SOTA for keyphrase generation. Additionally, we also fine-tune the pre-trained language models on named entity recognition(NER), question answering (QA), relation extraction (RE), abstractive summarization and achieve comparable performance with that of the SOTA, showing that learning rich representation of keyphrases is indeed beneficial for many other fundamental NLP tasks.\"\n  example_title: \"Example 2\"\nmodel-index:\n- name: DeDeckerThomas/keyphrase-generation-t5-small-openkp\n  results:\n  - task: \n      type: keyphrase-generation\n      name: Keyphrase Generation\n    dataset:\n      type: midas/openkp\n      name: openkp\n    metrics:\n      - type: F1@M (Present)\n        value: 0.246\n        name: F1@M (Present)\n      - type: F1@O (Present)\n        value: 0.151\n        name: F1@O (Present)\n      - type: F1@M (Absent)\n        value: 0.002\n        name: F1@M (Absent)\n      - type: F1@O (Absent)\n        value: 7.56e-5\n        name: F1@O (Absent)\n---\n# \ud83d\udd11 Keyphrase Generation model: T5-small-OpenKP\nKeyphrase extraction is a technique in text analysis where you extract the important keyphrases from a document. Thanks to these keyphrases humans can understand the content of a text very quickly and easily without reading it completely. Keyphrase extraction was first done primarily by human annotators, who read the text in detail and then wrote down the most important keyphrases. The disadvantage is that if you work with a lot of documents, this process can take a lot of time \u23f3. \n\nHere is where Artificial Intelligence \ud83e\udd16 comes in. Currently, classical machine learning methods, that use statistical and linguistic features, are widely used for the extraction process. Now with deep learning, it is possible to capture the semantic meaning of a text even better than these classical methods. Classical methods look at the frequency, occurrence and order of words in the text, whereas these neural approaches can capture long-term semantic dependencies and context of words in a text.\n\n\n## \ud83d\udcd3 Model Description\nThis model uses [T5-small model](https://huggingface.co/t5-small) as its base model and fine-tunes it on the [OpenKP dataset](https://huggingface.co/datasets/midas/openkp). Keyphrase generation transformers are fine-tuned as a text-to-text generation problem where the keyphrases are generated. The result is a concatenated string with all keyphrases separated by a given delimiter (i.e. \u201c;\u201d). These models are capable of generating present and absent keyphrases.\n\n## \u270b Intended Uses & Limitations\n### \ud83d\uded1 Limitations\n* Only works for English documents.\n* Sometimes the output doesn't make any sense.\n\n### \u2753 How To Use\n```python\n# Model parameters\nfrom transformers import (\n    Text2TextGenerationPipeline,\n    AutoModelForSeq2SeqLM,\n    AutoTokenizer,\n)\n\n\nclass KeyphraseGenerationPipeline(Text2TextGenerationPipeline):\n    def __init__(self, model, keyphrase_sep_token=\";\", *args, **kwargs):\n        super().__init__(\n            model=AutoModelForSeq2SeqLM.from_pretrained(model),\n            tokenizer=AutoTokenizer.from_pretrained(model),\n            *args,\n            **kwargs\n        )\n        self.keyphrase_sep_token = keyphrase_sep_token\n\n    def postprocess(self, model_outputs):\n        results = super().postprocess(\n            model_outputs=model_outputs\n        )\n        return [[keyphrase.strip() for keyphrase in result.get(\"generated_text\").split(self.keyphrase_sep_token) if keyphrase != \"\"] for result in results]\n\n```\n\n```python\n# Load pipeline\nmodel_name = \"ml6team/keyphrase-generation-t5-small-openkp\"\ngenerator = KeyphraseGenerationPipeline(model=model_name)\n```\n\n```python\ntext = \"\"\"\nKeyphrase extraction is a technique in text analysis where you extract the\nimportant keyphrases from a document. Thanks to these keyphrases humans can\nunderstand the content of a text very quickly and easily without reading it\ncompletely. Keyphrase extraction was first done primarily by human annotators,\nwho read the text in detail and then wrote down the most important keyphrases.\nThe disadvantage is that if you work with a lot of documents, this process\ncan take a lot of time. \nHere is where Artificial Intelligence comes in. Currently, classical machine\nlearning methods, that use statistical and linguistic features, are widely used\nfor the extraction process. Now with deep learning, it is possible to capture\nthe semantic meaning of a text even better than these classical methods.\nClassical methods look at the frequency, occurrence and order of words\nin the text, whereas these neural approaches can capture long-term\nsemantic dependencies and context of words in a text.\n\"\"\".replace(\"\\n\", \" \")\n\nkeyphrases = generator(text)\n\nprint(keyphrases)\n\n```\n\n```\n# Output\n[['keyphrase extraction', 'text analysis', 'artificial intelligence']]\n```\n\n## \ud83d\udcda Training Dataset\n[OpenKP](https://github.com/microsoft/OpenKP) is a large-scale, open-domain keyphrase extraction dataset with 148,124 real-world web documents along with 1-3 most relevant human-annotated keyphrases.\n\nYou can find more information in the [paper](https://arxiv.org/abs/1911.02671). \n\n## \ud83d\udc77\u200d\u2642\ufe0f Training Procedure\n### Training Parameters\n\n| Parameter | Value |\n| --------- | ------|\n| Learning Rate | 5e-5 |\n| Epochs | 50 |\n| Early Stopping Patience | 1 |\n\n### Preprocessing\nThe documents in the dataset are already preprocessed into list of words with the corresponding keyphrases. The only thing that must be done is tokenization and joining all keyphrases into one string with a certain seperator of choice( ```;``` ). \n```python\nfrom datasets import load_dataset\nfrom transformers import AutoTokenizer\n# Tokenizer\ntokenizer = AutoTokenizer.from_pretrained(\"t5-small\", add_prefix_space=True)\n# Dataset parameters\ndataset_full_name = \"midas/inspec\"\ndataset_subset = \"raw\"\ndataset_document_column = \"document\"\nkeyphrase_sep_token = \";\"\ndef preprocess_keyphrases(text_ids, kp_list):\n    kp_order_list = []\n    kp_set = set(kp_list)\n    text = tokenizer.decode(\n        text_ids, skip_special_tokens=True, clean_up_tokenization_spaces=True\n    )\n    text = text.lower()\n    for kp in kp_set:\n        kp = kp.strip()\n        kp_index = text.find(kp.lower())\n        kp_order_list.append((kp_index, kp))\n    kp_order_list.sort()\n    present_kp, absent_kp = [], []\n    for kp_index, kp in kp_order_list:\n        if kp_index < 0:\n            absent_kp.append(kp)\n        else:\n            present_kp.append(kp)\n    return present_kp, absent_kp\ndef preprocess_fuction(samples):\n    processed_samples = {\"input_ids\": [], \"attention_mask\": [], \"labels\": []}\n    for i, sample in enumerate(samples[dataset_document_column]):\n        input_text = \" \".join(sample)\n        inputs = tokenizer(\n            input_text,\n            padding=\"max_length\",\n            truncation=True,\n        )\n        present_kp, absent_kp = preprocess_keyphrases(\n            text_ids=inputs[\"input_ids\"],\n            kp_list=samples[\"extractive_keyphrases\"][i]\n            + samples[\"abstractive_keyphrases\"][i],\n        )\n        keyphrases = present_kp\n        keyphrases += absent_kp\n        target_text = f\" {keyphrase_sep_token} \".join(keyphrases)\n        with tokenizer.as_target_tokenizer():\n            targets = tokenizer(\n                target_text, max_length=40, padding=\"max_length\", truncation=True\n            )\n            targets[\"input_ids\"] = [\n                (t if t != tokenizer.pad_token_id else -100)\n                for t in targets[\"input_ids\"]\n            ]\n        for key in inputs.keys():\n            processed_samples[key].append(inputs[key])\n        processed_samples[\"labels\"].append(targets[\"input_ids\"])\n    return processed_samples\n# Load dataset\ndataset = load_dataset(dataset_full_name, dataset_subset)\n# Preprocess dataset\ntokenized_dataset = dataset.map(preprocess_fuction, batched=True)\n    \n```\n\n### Postprocessing\nFor the post-processing, you will need to split the string based on the keyphrase separator.\n```python\ndef extract_keyphrases(examples):\n    return [example.split(keyphrase_sep_token) for example in examples]\n```\n\n## \ud83d\udcdd Evaluation Results\n\nTraditional evaluation methods are the precision, recall and F1-score @k,m where k is the number that stands for the first k predicted keyphrases and m for the average amount of predicted keyphrases. In keyphrase generation you also look at F1@O where O stands for the number of ground truth keyphrases.\n\nThe model achieves the following results on the OpenKP test set:\n\n\nExtractive keyphrases\n\n| Dataset           | P@5  | R@5  | F1@5 | P@10 | R@10 | F1@10 | P@M  | R@M  | F1@M | P@O  | R@O  | F1@O |\n|:-----------------:|:----:|:----:|:----:|:----:|:----:|:-----:|:----:|:----:|:----:|:----:|:----:|:----:|\n| OpenKP Test Set   | 0.11 | 0.32 | 0.16 | 0.06 | 0.32 | 0.09  | 0.22 | 0.32 | 0.25 | 0.15 | 0.15 | 0.15 | \n\nAbstractive keyphrases\n\n| Dataset           | P@5   | R@5   | F1@5  | P@10   | R@10  | F1@10   | P@M   | R@M   | F1@M  | P@O      | R@O      | F1@O      |\n|:-----------------:|:-----:|:-----:|:-----:|:------:|:-----:|:-------:|:-----:|:-----:|:-----:|:--------:|:--------:|:---------:|\n| OpenKP Test Set   | 0.001 | 0.003 | 0.001 | 0.0004 | 0.004 | 0.0007  | 0.001 | 0.04  | 0.002 | 7.56e-e5 | 7.56e-e5 | 7.56e-e5  | \n\n## \ud83d\udea8 Issues\nPlease feel free to start discussions in the Community Tab.", "size_bytes": "242028283", "downloads": 19}