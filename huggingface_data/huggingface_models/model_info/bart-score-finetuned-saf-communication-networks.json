{"pretrained_model_name": "Short-Answer-Feedback/bart-score-finetuned-saf-communication-networks", "description": "---\nlanguage:\n- en\ndatasets:\n- Short-Answer-Feedback/saf_communication_networks_english\ntags:\n- generated_from_trainer\nwidget:\n- text: >-\n    Answer: In TCP there is a Sequence Number field to identify packets\n    individually for reliability. There is no Sequence Number in UDP. The UDP\n    header does not have an options field, while the TCP header does. In TCP\n    there is an Advertised Window field for the Sliding Window Protocol for Flow\n    Control. There is no Flow Control and therefore no Advertised Window field\n    in UDP. In TCP there there is only a Data Offset field that specifies the\n    header length. In UDP the whole Packet Length is transmitted. Reference:\n    Possible Differences : The UPD header (8 bytes) is much shorter than the TCP\n    header (20-60 bytes) The UDP header has a fixed length while the TCP header\n    has a variable length Fields contained in the TCP header and not the UDP\n    header : -Sequence number -Acknowledgment number -Reserved -Flags/Control\n    bits -Advertised window -Urgent Pointer -Options + Padding if the options\n    are UDP includes the packet length (data + header) while TCP has the header\n    length/data offset (just header) field instead The sender port field is\n    optional in UDP, while the source port in TCP is necessary to establish the\n    connection Question: State at least 4 of the differences shown in the\n    lecture between the UDP and TCP headers.\n---\n\n# bart-score-finetuned-saf-communication-networks\n\nThis model is a fine-tuned version of [facebook/bart-large](https://huggingface.co/facebook/bart-large) on the [saf_communication_networks_english](https://huggingface.co/datasets/Short-Answer-Feedback/saf_communication_networks_english) dataset for Short Answer Feedback (SAF), as proposed in [Filighera et al., ACL 2022](https://aclanthology.org/2022.acl-long.587).\n\n## Model description\n\nThis model was built on top of [BART](https://arxiv.org/abs/1910.13461), which is a sequence-to-sequence model trained with denoising as pretraining objective.\n\nIt expects inputs in the following format:\n```\nAnswer: [answer] Reference: [reference_answer] Question: [question]\n```\n\nIn the example above, `[answer]`, `[reference_answer]` and `[question]` should be replaced by the provided answer, the reference answer and the question to which they refer, respectively.\n\n\nThe outputs are formatted as follows:\n```\n[score] Feedback: [feedback]\n```\n\nHence, `[score]` will be a numeric value representing the score attributed to the provided answer, while `[feedback]` will be the textual feedback generated by the model according to the given answer.\n\n## Intended uses & limitations\n\nThis model is intended to be used for Short Answer Feedback generation in the context of college-level communication networks topics. Thus, it is not expected to have particularly good performance on sets of questions and answers out of this scope.\n\nIt is important to acknowledge that the model underperforms when a question that was not seen during training is given as input for inference. In particular, it tends to classify most answers as being correct and does not provide relevant feedback in such cases. Nevertheless, this limitation could be partially overcome by extending the dataset with the desired question (and associated answers) and fine-tuning it for a few epochs on the new data.\n\n## Training and evaluation data\n\nAs mentioned previously, the model was trained on the [saf_communication_networks_english](https://huggingface.co/datasets/Short-Answer-Feedback/saf_communication_networks_english) dataset, which is divided into the following splits.\n\n| Split                 | Number of examples |\n| --------------------- | ------------------ |\n| train                 | 1700\t             |\n| validation            | 427\t             |\n| test_unseen_answers   | 375\t             |\n| test_unseen_questions | 479                |\n\nEvaluation was performed on the `test_unseen_answers` and `test_unseen_questions` splits.\n\n## Training procedure\n\nThe [Trainer API](https://huggingface.co/docs/transformers/main_classes/trainer#transformers.Seq2SeqTrainer) was used to fine-tune the model. The code utilized for pre-processing and training was mostly adapted from the [summarization script](https://github.com/huggingface/transformers/tree/main/examples/pytorch/summarization) made available by HuggingFace.\n\nTraining was completed in a little under 1 hour on a GPU on Google Colab.\n\n### Training hyperparameters\n\nThe following hyperparameters were used during training:\n- num_epochs: 8\n- optimizer: Adam with betas=(0.9,0.999) and epsilon=1e-08\n- learning_rate: 5e-05\n- lr_scheduler_type: linear\n- train_batch_size: 1\n- gradient_accumulation_steps: 4\n- eval_batch_size: 4\n- mixed_precision_training: Native AMP\n- PyTorch seed: 42\n\n### Framework versions\n\n- Transformers 4.26.0\n- Pytorch 1.13.1+cu116\n- Datasets 2.9.0\n- Tokenizers 0.13.2\n\n## Evaluation results\n\nThe generated feedback was evaluated through means of the [SacreBLEU](https://huggingface.co/spaces/evaluate-metric/sacrebleu), [ROUGE-2](https://huggingface.co/spaces/evaluate-metric/rouge), [METEOR](https://huggingface.co/spaces/evaluate-metric/meteor), [BERTScore](https://huggingface.co/spaces/evaluate-metric/bertscore) metrics from HuggingFace, while the [Root Mean Squared Error](https://scikit-learn.org/stable/modules/generated/sklearn.metrics.mean_squared_error) loss from scikit-learn was used for evaluation of the predicted scores in relation to the golden label scores.\n\nThe following results were achieved.\n\n| Split                 | SacreBLEU | ROUGE-2 | METEOR | BERTScore | RMSE  |\n| --------------------- | :-------: | :-----: | :----: | :-------: | :---: |\n| test_unseen_answers   | 30.5\t    | 46.4    | 58.2   | 68.0      | 0.373 |\n| test_unseen_questions | 0.6       | 9.5     | 18.8   | 26.7      | 0.544 |\n\n\nThe script used to compute these metrics and perform evaluation can be found in the `evaluation.py` file in this repository.\n\n## Usage\n\nThe example below shows how the model can be applied to generate feedback to a given answer.\n\n```python\nfrom transformers import AutoModelForSeq2SeqLM, AutoTokenizer\n\nmodel = AutoModelForSeq2SeqLM.from_pretrained('Short-Answer-Feedback/bart-score-finetuned-saf-communication-networks')\ntokenizer = AutoTokenizer.from_pretrained('Short-Answer-Feedback/bart-score-finetuned-saf-communication-networks')\n\nexample_input = 'Answer: In TCP there is a Sequence Number field to identify packets individually for reliability. There is no Sequence Number in UDP. The UDP header does not have an options field, while the TCP header does. In TCP there is an Advertised Window field for the Sliding Window Protocol for Flow Control. There is no Flow Control and therefore no Advertised Window field in UDP. In TCP there there is only a Data Offset field that specifies the header length. In UDP the whole Packet Length is transmitted. Reference: Possible Differences : The UPD header (8 bytes) is much shorter than the TCP header (20-60 bytes) The UDP header has a fixed length while the TCP header has a variable length Fields contained in the TCP header and not the UDP header : -Sequence number -Acknowledgment number -Reserved -Flags/Control bits -Advertised window -Urgent Pointer -Options + Padding if the options are UDP includes the packet length (data + header) while TCP has the header length/data offset (just header) field instead The sender port field is optional in UDP, while the source port in TCP is necessary to establish the connection Question: State at least 4 of the differences shown in the lecture between the UDP and TCP headers.'\ninputs = tokenizer(example_input, max_length=256, padding='max_length', truncation=True, return_tensors='pt')\n\ngenerated_tokens = model.generate(\n                inputs['input_ids'],\n                attention_mask=inputs['attention_mask'],\n                max_length=128\n            )\noutput = tokenizer.batch_decode(generated_tokens, skip_special_tokens=True)[0]\n```\n\nThe output produced by the model then looks as follows:\n\n```\n1.0 Feedback: The response correctly identifies four differences between TCP and UDP headers.\n```\n\n## Related Work\n\n[Filighera et al., ACL 2022](https://aclanthology.org/2022.acl-long.587) trained a [T5 model](https://huggingface.co/docs/transformers/model_doc/t5) on this dataset, providing a baseline for SAF generation. The entire code used to define and train the model can be found on [GitHub](https://github.com/SebOchs/SAF).", "size_bytes": "1625541389", "downloads": 8}