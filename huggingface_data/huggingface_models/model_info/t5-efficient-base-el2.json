{"pretrained_model_name": "google/t5-efficient-base-el2", "description": "---\nlanguage:\n- en\ndatasets:\n- c4\ntags:\n- deep-narrow\ninference: false\n\nlicense: apache-2.0\n---\n\n# T5-Efficient-BASE-EL2 (Deep-Narrow version)\n\nT5-Efficient-BASE-EL2 is a variation of [Google's original T5](https://ai.googleblog.com/2020/02/exploring-transfer-learning-with-t5.html) following the [T5 model architecture](https://huggingface.co/docs/transformers/model_doc/t5).\nIt is a *pretrained-only* checkpoint and was released with the\npaper **[Scale Efficiently: Insights from Pre-training and Fine-tuning Transformers](https://arxiv.org/abs/2109.10686)**\nby *Yi Tay, Mostafa Dehghani, Jinfeng Rao, William Fedus, Samira Abnar, Hyung Won Chung, Sharan Narang, Dani Yogatama, Ashish Vaswani, Donald Metzler*.\n\nIn a nutshell, the paper indicates that a **Deep-Narrow** model architecture is favorable for **downstream** performance compared to other model architectures\nof similar parameter count.\n\nTo quote the paper:\n\n> We generally recommend a DeepNarrow strategy where the model\u2019s depth is preferentially increased\n> before considering any other forms of uniform scaling across other dimensions. This is largely due to\n> how much depth influences the Pareto-frontier as shown in earlier sections of the paper. Specifically, a\n> tall small (deep and narrow) model is generally more efficient compared to the base model. Likewise,\n> a tall base model might also generally more efficient compared to a large model. We generally find\n> that, regardless of size, even if absolute performance might increase as we continue to stack layers,\n> the relative gain of Pareto-efficiency diminishes as we increase the layers, converging at 32 to 36\n> layers. Finally, we note that our notion of efficiency here relates to any one compute dimension, i.e.,\n> params, FLOPs or throughput (speed). We report all three key efficiency metrics (number of params,\n> FLOPS and speed) and leave this decision to the practitioner to decide which compute dimension to\n> consider.\n\nTo be more precise, *model depth* is defined as the number of transformer blocks that are stacked sequentially.\nA sequence of word embeddings is therefore processed sequentially by each transformer block.\n\n## Details model architecture\n\nThis model checkpoint - **t5-efficient-base-el2** - is of model type **Base** with the following variations:\n- **el** is **2**\n\nIt has **152.13** million parameters and thus requires *ca.* **608.51 MB** of memory in full precision (*fp32*)\n or  **304.26 MB** of memory in half precision (*fp16* or *bf16*).\n\nA summary of the *original* T5 model architectures can be seen here:\n\n| Model | nl (el/dl) | ff | dm | kv | nh | #Params|\n| ----| ---- | ---- | ---- | ---- | ---- | ----|\n| Tiny | 4/4 | 1024 | 256 | 32 | 4 | 16M|\n| Mini | 4/4 | 1536 | 384 | 32 | 8 | 31M|\n| Small | 6/6 | 2048 | 512 | 32 | 8 | 60M|\n| Base | 12/12 | 3072 | 768 | 64 | 12 | 220M|\n| Large | 24/24 | 4096 | 1024 | 64 | 16 | 738M|\n| Xl | 24/24 | 16384 | 1024 | 128 | 32 | 3B|\n| XXl | 24/24 | 65536 | 1024 | 128 | 128 | 11B|\n\nwhereas the following abbreviations are used:\n\n| Abbreviation | Definition |\n| ----| ---- |\n| nl | Number of transformer blocks (depth) |\n| dm | Dimension of embedding vector (output vector of transformers block) |\n| kv | Dimension of key/value projection matrix |\n| nh | Number of attention heads |\n| ff | Dimension of intermediate vector within transformer block (size of feed-forward projection matrix) | \n| el | Number of transformer blocks in the encoder (encoder depth) | \n| dl | Number of transformer blocks in the decoder (decoder depth) | \n| sh | Signifies that attention heads are shared | \n| skv | Signifies that key-values projection matrices are tied | \n\nIf a model checkpoint has no specific, *el* or *dl* than both the number of encoder- and decoder layers correspond to *nl*.\n\n## Pre-Training\n\nThe checkpoint was pretrained on the [Colossal, Cleaned version of Common Crawl (C4)](https://huggingface.co/datasets/c4) for 524288 steps using \nthe span-based masked language modeling (MLM) objective.\n\n## Fine-Tuning\n\n**Note**: This model is a **pretrained** checkpoint and has to be fine-tuned for practical usage.\nThe checkpoint was pretrained in English and is therefore only useful for English NLP tasks.\nYou can follow on of the following examples on how to fine-tune the model:\n\n*PyTorch*:\n\n- [Summarization](https://github.com/huggingface/transformers/tree/master/examples/pytorch/summarization)\n- [Question Answering](https://github.com/huggingface/transformers/blob/master/examples/pytorch/question-answering/run_seq2seq_qa.py)\n- [Text Classification](https://github.com/huggingface/transformers/tree/master/examples/pytorch/text-classification) - *Note*: You will have to slightly adapt the training example here to make it work with an encoder-decoder model.\n\n*Tensorflow*:\n\n- [Summarization](https://github.com/huggingface/transformers/tree/master/examples/tensorflow/summarization)\n- [Text Classification](https://github.com/huggingface/transformers/tree/master/examples/tensorflow/text-classification) - *Note*: You will have to slightly adapt the training example here to make it work with an encoder-decoder model.\n\n*JAX/Flax*:\n\n- [Summarization](https://github.com/huggingface/transformers/tree/master/examples/flax/summarization)\n- [Text Classification](https://github.com/huggingface/transformers/tree/master/examples/flax/text-classification) - *Note*: You will have to slightly adapt the training example here to make it work with an encoder-decoder model.\n\n## Downstream Performance\n\nTODO: Add table if available\n\n## Computational Complexity\n\nTODO: Add table if available\n\n## More information\n\nWe strongly recommend the reader to go carefully through the original paper **[Scale Efficiently: Insights from Pre-training and Fine-tuning Transformers](https://arxiv.org/abs/2109.10686)** to get a more nuanced understanding of this model checkpoint.\nAs explained in the following [issue](https://github.com/google-research/google-research/issues/986#issuecomment-1035051145), checkpoints including the *sh* or *skv* \nmodel architecture variations have *not* been ported to Transformers as they are probably of limited practical usage and are lacking a more detailed description. Those checkpoints are kept [here](https://huggingface.co/NewT5SharedHeadsSharedKeyValues) as they might be ported potentially in the future.", "size_bytes": "608514463", "downloads": 6}