{"pretrained_model_name": "com3dian/Bart-large-paper2slides-summarizer", "description": "---\nlanguage:\n- en\ntags:\n- summarization\nwidget:\n- text: | \n        We here recount the main elements of a classic bag-of-features model before introducing the simpler DNN-based BagNets in the next paragraph. Bag-of-feature representations can be described by analogy to bag-of-words representations. With bag-of-words, one counts the number of occurrences of words from a vocabulary in a document. This vocabulary contains important words (but not common ones like \"and\" or \"the\") and word clusters (i.e. semantically similar words like \"gigantic\" and \"enormous\" are subsumed). The counts of each word in the vocabulary are assembled as one long term vector. This is called the bag-of-words document representation because all ordering of the words is lost. Likewise, bag-of-feature representations are based on a vocabulary of visual words which represent clusters of local image features. The term vector for an image is then simply the number of occurrences of each visual word in the vocabulary. This term vector is used as an input to a classifier (e.g. SVM or MLP). Many successful image classification models have been based on this pipeline (Csurka et al., 2004; Jurie & Triggs, 2005; Zhang et al., 2007; Lazebnik et al., 2006), see O\u2019Hara & Draper (2011) for an up-to-date overview.\n- text: | \n        The goal of reducing sequential computation also forms the foundation of the Extended Neural GPU [16], ByteNet [18] and ConvS2S [9], all of which use convolutional neural networks as basic building block, computing hidden representations in parallel for all input and output positions. In these models, the number of operations required to relate signals from two arbitrary input or output positions grows in the distance between positions, linearly for ConvS2S and logarithmically for ByteNet. This makes it more difficult to learn dependencies between distant positions [12]. In the Transformer this is reduced to a constant number of operations, albeit at the cost of reduced effective resolution due to averaging attention-weighted positions, an effect we counteract with Multi-Head Attention as described in section 3.2. \n        Self-attention, sometimes called intra-attention is an attention mechanism relating different positions of a single sequence in order to compute a representation of the sequence. Self-attention has been used successfully in a variety of tasks including reading comprehension, abstractive summarization, textual entailment and learning task-independent sentence representations [4, 27, 28, 22].\n        End-to-end memory networks are based on a recurrent attention mechanism instead of sequencealigned recurrence and have been shown to perform well on simple-language question answering and language modeling tasks [34].\n        To the best of our knowledge, however, the Transformer is the first transduction model relying entirely on self-attention to compute representations of its input and output without using sequencealigned RNNs or convolution. In the following sections, we will describe the Transformer, motivate self-attention and discuss its advantages over models such as [17, 18] and [9].\nlicense:\n- mit\npipeline_tag: summarization\n---\n# Bart-Large Summarization Model\n\n![Bart Logo](https://huggingface.co/front/assets/huggingface_logo.svg)\n\nThis repository contains the **Bart-Large-paper2slides-summarizer Model**, which has been fine-tuned on the [Automatic Slide Generation from Scientific Papers dataset](https://www.kaggle.com/datasets/andrewmvd/automatic-slide-generation-from-scientific-papers) using unsupervised learning techniques using an algorithm from the paper entitled '[Unsupervised Machine Translation Using Monolingual Corpora Only](https://arxiv.org/abs/1711.00043)'.\nIts primary focus is to summarize **scientific texts** with precision and accuracy, the model is parallelly trained with the [**Bart-large-paper2slides-expander**](https://huggingface.co/com3dian/Bart-large-paper2slides-expander) from the same contributor.\n\n## Model Details\n\n- **Model Architecture**: Bart-Large\n- **Fine-tuning Dataset**: [Automatic Slide Generation from Scientific Papers](https://www.kaggle.com/datasets/andrewmvd/automatic-slide-generation-from-scientific-papers)\n- **Fine-tuning Method**: Unsupervised Learning\n\n[Bart](https://huggingface.co/transformers/model_doc/bart.html) (Bidirectional and Auto-Regressive Transformers) is a sequence-to-sequence (seq2seq) model developed by Facebook AI Research. It has shown exceptional performance in various natural language processing (NLP) tasks such as text summarization, text generation, and machine translation.\n\nThis particular model, Bart-Large, is the larger version of the Bart model. It consists of 12 encoder and decoder layers and has a total of 400 million parameters.\n\n## Usage\n\nTo use this model, you can leverage the Hugging Face [Transformers](https://huggingface.co/transformers/) library. Here's an example of how to use it in Python:\n\n```python\nfrom transformers import BartTokenizer, BartForConditionalGeneration, pipeline\n\n# Load the model and tokenizer\nmodel_name = \"com3dian/Bart-large-paper2slides-summarizer\"\ntokenizer = BartTokenizer.from_pretrained(model_name)\nmodel = BartForConditionalGeneration.from_pretrained(model_name)\n\n# Generate summary from input text\ninput_text = \"Your input text here...\"\ninput_ids = tokenizer.encode(input_text, return_tensors=\"pt\")\noutput = model.generate(input_ids)\n\n# Decode generated summaries\nsummary = tokenizer.decode(output[0], skip_special_tokens=True)\nprint(summary)\n\n# Or using the pipeline API\nsummarizer = pipeline(\"summarization\", model=model_name)\nsummary = summarizer(input_text, max_length=50, min_length=30, do_sample=False)\nprint(summary)\n```\n\nEnsure you have the `transformers` library installed before running the code. You can install it using `pip`:\n\n```\npip install transformers\n```\n\n## Model Fine-tuning Details\n\nThe fine-tuning process for this model involved training on the slide generation dataset using unsupervised learning techniques. Unsupervised learning refers to training a model without explicit human-labeled targets. Instead, the model learns to back-summarize the input provided by the expansion model, into the original texts.\n\nThe specific hyperparameters and training details used for fine-tuning this model are as follows:\n\n- Batch Size: 4\n- Learning Rate: 2e-6\n- Training Steps: 3*7\n- Optimizer: AdamW\n\n## Model Performance\n\nThe Bart-Large Slide Generation Model has undergone thorough human evaluation in a wide range of scientific domains, including AI, mathematics, statistics, history, geography, and climate science, to compare its performance with the [Bart-large-cnn](https://huggingface.co/facebook/bart-large-cnn) model.\n\n## Acknowledgments\n\nWe would like to acknowledge the authors of the Bart model and the creators of the slide generation dataset for their valuable contributions, which have enabled the development of this fine-tuned model.\n\nIf you use this model or find it helpful in your work, please consider citing the original Bart model and the slide generation dataset to provide proper credit to the respective authors.\n\n## License\n\nThis model and the associated code are released under the [MIT license](https://opensource.org/license/mit/).", "size_bytes": "1625537293", "downloads": 1011}