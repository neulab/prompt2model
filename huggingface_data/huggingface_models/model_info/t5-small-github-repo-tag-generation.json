{"pretrained_model_name": "nandakishormpai/t5-small-github-repo-tag-generation", "description": "---\nlicense: apache-2.0\ntags:\n- generated_from_trainer\n- documentation_tag\n- tag_generation\n- github\n- github_tag\n- tagging\n- github_repo\n- summarization\nmetrics:\n- rouge\nmodel-index:\n- name: t5-small-github-repo-tag-generation\n  results: []\nwidget:\n- text: \"susya  plant disease detector ml powered app to assist farmers in crop disease detection and alerts product walkthrough  download product apk here machine learning python notebook solutions system to detect the problem when it arises and warn the farmers disease detection using machine learning model enabled through android app which uses flask api solution to overcome the problem once it arises remedy is suggested for the disease detected by the app using ml model solution that will ensure that the problem will never occur in the future again pdf report is generated on the disease predicted along with user information pdf can be used as a document to be submitted in nearby krishibhavan thereby seeking help easily method that will reduce the impact of the dilemma to a significant level disease detected news can be sent to other users as a notification which contatins userplant and disease this will help other farmers take up precautions thereby reducing the impact of the dilemma to a significant level considering a region machine learning model multiclass image classifier built on pytorch framework using cnn architecture currently project detects 17 states of disease in 4 plants  aiming kerala state  namely cherry pepper potato and tomato framework  pytorch architecture  convolutional neural networks validation accuracy  777 how to train upload the python notebook to google colab and run each cell for training the model i have included a demo dataset to configure quickly you can use this kaggle dataset which is the original one with huge amount of pictures how it works the input image dataset is converted to tensor and is passed through a cnn model returning an output value corresponding to the plant disease input image tensor is passed through four convolutional layers and then flattened and inputted to fully connected layers api api is built using flask framework and hosted in render the api provides two functionalities they are plant disease detection accepts a post request with an image in the form of base64 string and returns plant disease and remedy notification accepts a post request with plant user and disease  which is then pushed as a notification to other users to warn them regarding a probable outbreak of disease how to use api has been built on this classifier url   user has to send a post request to the given api with base64 string of the image to be input python import requests url   imgdata  base64 string of image r  requestsposturljson  imageimgdata printrtextstrip outputpython diseaseseptoria leaf spotplanttomatoremedyremove infected leaves immediatelyfungonil and daconil  app download product apk here to run app shell  cd app  flutter run to build app shell  cd app  flutter build apk features authentication using google oauth user profile page uses camera or device media to get an image of the crop preview the image and sends it to api for disease detection result page showing detected disease and remedy generates a pdf report to saveshare predicted disease details option to send the generated result as a notification warning to other users tech stack used python pytorch flask flutter firebase contributors nanda kishor m paiml model api ajay krishna k v flutter dev api hari krishnan uml model data collection antony s johnflutter dev\"\nexample_title: 'Github Cleaned Readme #1'\nlanguage:\n- en\npipeline_tag: summarization\n---\n\n<!-- This model card has been generated automatically according to the information the Trainer had access to. You\nshould probably proofread and complete it, then remove this comment. -->\n\n# t5-small-github-repo-tag-generation\n\nMachine Learning model to generate Tags for Github Repositories based on their Documentation [README.md] . This model is a fine-tuned version of [t5-small](https://huggingface.co/t5-small) fine-tuned on a collection of repositoreis from [Kaggle/vatsalparsaniya/github-repositories-analysis](https://www.kaggle.com/datasets/vatsalparsaniya/github-repositories-analysis).  While usually formulated as a multi-label classification problem, this model deals with _tag generation_ as a text2text generation task (inspiration and reference: [fabiochiu/t5-base-tag-generation](https://huggingface.co/fabiochiu/t5-base-tag-generation)).\n<br><br>\nThe Inference API here expects a cleaned readme text, the code for cleaning the readme is also given below.\n<br><br>\nFinetuning Notebook Reference: [Hugging face summarization notebook](https://github.com/huggingface/notebooks/blob/main/examples/summarization.ipynb).\n\n\n# How to use the model\n\nInput : Github Repo URL<br>\nOutput : Tags\n\nRemarks: Ensure the repo has README.<b>md</b>\n### Installations\n\n```python\npip install transformers nltk clean-text beautifulsoup4\n```\n### Code\nImports \n```python\nfrom transformers import AutoTokenizer, AutoModelForSeq2SeqLM\nimport re\nimport nltk\nnltk.download('punkt')\nfrom cleantext import clean\nfrom bs4 import BeautifulSoup\nfrom markdown import Markdown\nimport requests\nfrom io import StringIO\nimport string\n```\n\nPreprocessing\n```python\n# Script to convert Markdown to plain text\n# Reference : Stackoverflow == https://stackoverflow.com/questions/761824/python-how-to-convert-markdown-formatted-text-to-text\n\ndef unmark_element(element, stream=None):\n    if stream is None:\n        stream = StringIO()\n    if element.text:\n        stream.write(element.text)\n    for sub in element:\n        unmark_element(sub, stream)\n    if element.tail:\n        stream.write(element.tail)\n    return stream.getvalue()\n\n\n# patching Markdown\nMarkdown.output_formats[\"plain\"] = unmark_element\n__md = Markdown(output_format=\"plain\")\n__md.stripTopLevelTags = False\n\n\ndef unmark(text):\n    return __md.convert(text)\n\ndef readme_extractor(github_repo_url):\n    try:\n        \n        # Get repo HTML using BeautifulSoup\n        html_content = requests.get(github['python', 'machine learning', 'ml', 'cnn']_repo_url).text\n        soup = BeautifulSoup(html_content, \"html.parser\")\n\n        # Get README File URL from Repository\n        readme_url = \"https://github.com/\" + soup.find(\"a\",{\"title\":\"README.md\"}).get(\"href\")\n\n        # Generate raw readme file URL\n        # https://github.com/rasbt/python-machine-learning-book/blob/master/README.md   -->   https://raw.githubusercontent.com/rasbt/python-machine-learning-book/master/README.md\n        readme_raw_url = readme_url.replace(\"/blob/\",\"/\")\n        readme_raw_url = readme_raw_url.replace(\"github.com\",\"raw.githubusercontent.com\")\nhttps://github.com/Lightning-AI/lightning\n        readme_html_content = requests.get(readme_raw_url ).text\n        readme_soup = BeautifulSoup(readme_html_content, \"html.parser\")\n        readme_text = readme_soup.get_text() \n        documentation_text = unmark(readme_text)\n        return documentation_text\n    except:\n        print(\"FAILED : \",github_repo_url )\n        return \"README_NOT_MARKDOWN\"\n\ndef clean_readme(readme):\n    text = clean(readme, no_emoji=True)\n    lst = re.findall('http://\\S+|https://\\S+', text)\n    for i in lst:\n        text = text.replace(i, '')\n    text = \"\".join([i for i in text if i not in string.punctuation])\n    text = text.lower()\n    text = text.replace(\"\\n\",\" \")\n    return text\n```\nPostprocess Tags  [Removing duplicates]\n```python\ndef post_process_tags(tag_string):\n    final_tags = []\n    for tag in tag_string.split(\",\"):\n      if tag.strip() in final_tags or len(tag.strip()) <=1:\n        continue\n      final_tags.append(tag.strip())\n    return final_tags\n```\n\nMain Function\n```python\ndef github_tags_generate(github_repo_url):\n    readme = readme_extractor(github_repo_url)\n    readme = clean_readme(readme)\n    inputs = tokenizer([readme], max_length=1536, truncation=True, return_tensors=\"pt\")\n    output = model.generate(**inputs, num_beams=8, do_sample=True, min_length=10,\n                            max_length=128)\n    decoded_output = tokenizer.batch_decode(output, skip_special_tokens=True)[0]\n    tags = post_process_tags(decoded_output)\n\n    return tags\n\n\n\ngithub_tags_generate(\"https://github.com/Enter_Repo_URL\")\n\n# github_tags_generate(\"https://github.com/nandakishormpai/Plant_Disease_Detector\")\n# ['python', 'machine learning', 'ml', 'cnn']\n```\n\n## Dataset Preparation\nOver the 1000 articles from the dataset, only 870 had tags and the readme was longer than 50 characters. They were filtered out and using BeautifulSoup, README.md was scraped out.\n\n\n## Intended uses & limitations\n\nThe results might contain duplicate tags that must be handled in the postprocessing of results. postprocessing code also given.\n\n\n## Results\n\nIt achieves the following results on the evaluation set:\n- Loss: 1.8196\n- Rouge1: 25.0142\n- Rouge2: 8.1802\n- Rougel: 22.77\n- Rougelsum: 22.8017\n- Gen Len: 19.0\n\n\n### Training hyperparameters\n\nThe following hyperparameters were used during training:\n- learning_rate: 2e-05\n- train_batch_size: 8\n- eval_batch_size: 8\n- seed: 42\n- optimizer: Adam with betas=(0.9,0.999) and epsilon=1e-08\n- lr_scheduler_type: linear\n- num_epochs: 40\n- mixed_precision_training: Native AMP\n\n\n\n### Framework versions\n\n- Transformers 4.26.1\n- Pytorch 1.13.1+cu116\n- Datasets 2.10.0\n- Tokenizers 0.13.2\n", "size_bytes": "242071641", "downloads": 24}